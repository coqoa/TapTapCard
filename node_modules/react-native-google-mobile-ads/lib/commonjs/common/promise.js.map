{"version":3,"sources":["promise.ts"],"names":["promiseDefer","deferred","promise","resolve","reject","Promise","promiseWithOptionalCallback","callback","then","result","length","catch","error"],"mappings":";;;;;;;;AAiBA;;AAjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACO,SAASA,YAAT,GAAwB;AAC7B,QAAMC,QAIL,GAAG;AAAEC,IAAAA,OAAO,EAAE,IAAX;AAAiBC,IAAAA,OAAO,EAAE,MAAM,CAAE,CAAlC;AAAoCC,IAAAA,MAAM,EAAE,MAAM,CAAE;AAApD,GAJJ;AAMAH,EAAAA,QAAQ,CAACC,OAAT,GAAmB,IAAIG,OAAJ,CAAY,CAACF,OAAD,EAAUC,MAAV,KAAqB;AAClDH,IAAAA,QAAQ,CAACE,OAAT,GAAmBA,OAAnB;AACAF,IAAAA,QAAQ,CAACG,MAAT,GAAkBA,MAAlB;AACD,GAHkB,CAAnB;AAKA,SAAOH,QAAP;AACD;AAED;AACA;AACA;AACA;;;AACO,SAASK,2BAAT,CACLJ,OADK,EAELK,QAFK,EAGL;AACA,MAAI,CAAC,0BAAWA,QAAX,CAAL,EAA2B;AACzB,WAAOL,OAAP;AACD;;AAED,SAAOA,OAAO,CACXM,IADI,CACCC,MAAM,IAAI;AACd,QAAIF,QAAQ,IAAIA,QAAQ,CAACG,MAAT,KAAoB,CAApC,EAAuC;AACrCH,MAAAA,QAAQ,CAAC,IAAD,CAAR;AACD,KAFD,MAEO,IAAIA,QAAJ,EAAc;AACnBA,MAAAA,QAAQ,CAAC,IAAD,EAAOE,MAAP,CAAR;AACD;;AAED,WAAOA,MAAP;AACD,GATI,EAUJE,KAVI,CAUEC,KAAK,IAAI;AACd,QAAIL,QAAJ,EAAc;AACZA,MAAAA,QAAQ,CAACK,KAAD,CAAR;AACD;;AACD,WAAOP,OAAO,CAACD,MAAR,CAAeQ,KAAf,CAAP;AACD,GAfI,CAAP;AAgBD","sourcesContent":["/*\n * Copyright (c) 2016-present Invertase Limited & Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this library except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isFunction } from './validate';\n\n/**\n *\n */\nexport function promiseDefer() {\n  const deferred: {\n    promise: Promise<unknown> | null;\n    resolve: (value: unknown) => void;\n    reject: (value: unknown) => void;\n  } = { promise: null, resolve: () => {}, reject: () => {} };\n\n  deferred.promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n\n  return deferred;\n}\n\n/**\n * @param promise\n * @param callback\n */\nexport function promiseWithOptionalCallback(\n  promise: Promise<unknown>,\n  callback: (a: unknown, b?: unknown) => void,\n) {\n  if (!isFunction(callback)) {\n    return promise;\n  }\n\n  return promise\n    .then(result => {\n      if (callback && callback.length === 1) {\n        callback(null);\n      } else if (callback) {\n        callback(null, result);\n      }\n\n      return result;\n    })\n    .catch(error => {\n      if (callback) {\n        callback(error);\n      }\n      return Promise.reject(error);\n    });\n}\n"]}